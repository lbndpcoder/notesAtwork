[TOC]

# 鸡蛋的X种扔法

##1. 2个鸡蛋100层楼

​	先说问题是什么吧，给你两个鸡蛋如何用最少的次数去判断鸡蛋在100层楼 **恰好** 在哪一层楼会碎。关键的词就是恰好这个词。假如说一共10层楼，你直接从10楼扔下去，鸡蛋碎了，但是你没法说恰好，因为你从9层楼扔下去鸡蛋也会碎，你从8层楼可能也会碎。所以如何找到 k 层楼不碎，k+1 就碎了这个楼层，而且在有限的鸡蛋的个数的前提下使得你扔的次数尽可能的少。

​	现在首先考虑的是 1 个鸡蛋的情况，1个鸡蛋你随便在某一个大于1的楼层扔，运气好的话没碎，你下一次再随便扔就会导致如果碎了，你怎么判断这个鸡蛋是恰好碎的还是你扔的这个楼层太高了呢？所以 1 个鸡蛋只能从1楼一次一次的扔了。

​	但是两个鸡蛋呢？第一个鸡蛋在 $k_{1}$ 层扔出去可以认为减少搜索范围的策略，然后第二个鸡蛋就可以在已经知道的信息下进行操作。比如第一个鸡蛋仔 $k_{1}$ 的位置扔了出去，如果碎了，那么说明第二个鸡蛋尝试的范围只能是从1到 $k_{1} - 1$ 这个范围，如果没碎的话，第一个鸡蛋继续扔（第二个鸡蛋后补）尝试范围能是 $k_{1} + 1$ 到 K（K为总的楼层的高度）。

​	所以问题就是如何找到一个扔鸡蛋的策略，主要是第一个鸡蛋扔的策略，比如第一次在 $k_{1}$ 层扔，如果碎了那么第二个鸡蛋的搜索范围为$(1,k_{1} - 1)$那么此时就相当于需要扔 $k_1$ 次 才能判断鸡蛋在哪里碎的。两个鸡蛋第一个鸡蛋无论如何花哨的扔第二个鸡蛋都需要默默的从最底层扔起来，当然我们要考虑的是最坏的情况，就像一个鸡蛋楼层有多高我们就默认扔多少次一样，第二个鸡蛋的扔的次数由第一个鸡蛋确定的空间决定。

​	那么只设定了第一个鸡蛋的第一个位置为$k_{1}$是不够，需要将第一个鸡蛋仔没碎的后续扔的楼层都设定出来，最后得到的所有的情况中得到的次数最多的那个在所有的策略中最多的那个的集合中是最少的就是你要求的解。通过对 $k_1,k_2,k_3\dots N$ 数值的探索，能找到在每一个序列确定的情况下找到最多的次数为这个策略的目标次数。而我们要找的是所有的可能的序列的目标次数最少的。

​	所以现在的问题就是如何找到这个序列（策略）的每一个值（这个数值代表的是扔的层数）使得找到的扔的次数最少。

​	现在考虑这样一个问题，假设我们的策略为：
$$
(k_1,k_2,k_3,\dots k_p,N)
$$
其中必须要包含 N （N为楼的高度），也就是说模拟出来在每一层扔第一个鸡蛋分别碎或者不碎的情况：

-  如果碎了那么第二个鸡蛋登场，进行“挨层式”扔鸡蛋；
- 如果没碎那么继续按照第一个鸡蛋的既定路线（序列）；

$$
F =\sum_{i} K_{i}= N+\frac{(1+p) p}{2}
$$

$K_{i}$代表的是在第$k_{i}$层（最后一个$K_i$是N）扔1号鸡蛋如果碎了的话需要2号鸡蛋继续扔的次数，就是将所有的情况都列出来，那么和是一个固定的数字 F ；我们的目标是找到一个序列使得在所有的序列中这个序列中某种次数最多的可能是最少的。因为固定了序列的长度，假设一个 p ，那么此时存在一个平均数值：
$$
M=\frac{F}{p+1}
$$
也就是说如果任意一个序列中如果存在某种可能的尝试次数大于平均值 M ，那么这个序列的次数就是 M ，而我们能找到一个序列中所有的可能次数都是 M 的话那么就可以使得这个序列是最佳的序列（策略）。

也就是说使得存在：
$$
\begin{aligned}
k_{1} &=k_{2}-k_{1}+1 \\
k_{2}-k_{1}+1&=k_{3}-k_{2}+2 \\
\dots \\
k_{p-1}-k_{p-2}+p-2&=k_{p}-k_{p-1}+p-1
\end{aligned}
$$
可以得到（后面有 p 项）：
$$
k_{p}=k_{1}+\left(k_{1}-1\right)+\left(k_{1}-2\right)+\cdots
$$
$(k_1,2k_1-1,3k_1-3,\dots,N)$ 这样的序列，所以可以知道如果第一个选择时$k_1$那么下一个楼层的选择是比$k_1$大$k_1 - 1$的楼层。所以就有：
$$
k_{1}+\left(k_{1}-1\right)+\left(k_{1}-2\right)+\cdots+1 \sim N \Longrightarrow \frac{k_{1}\left(k_{1}+1\right)}{2}=N
$$
向上取整，因为一定要保证最后的范围包含N。这样就可以确定了初始楼层的选择以及后续的策略然后计算出在每一个楼层碎了的话第二个鸡蛋需要尝试的次数，找到其中的最大的数值就是最后的结果。

## 2.  H层楼M个鸡蛋 （Leetcode 887）

### 2.1 模拟所有的情况

​	有了上面的 2 个鸡蛋的解决方案，现在的 M 个鸡蛋，还需要将所有的情况进行模拟：

- 如果第一个次投掷的楼层为 $k_1$ 那么：
  - 如果碎了，说明继续需要用 M - 1个鸡蛋在 $k_1 - 1$ 的楼层和下面的楼层进行尝试；
  - 如果没碎，说明需要用 M 个鸡蛋仔$H- k_1$的楼层进行尝试； 

所以后续的都是这样一个策略，所以整个问题就被缩小为部分范围，是一个常见的 DP 的思路。那么此时可以假设如果在H层楼扔M个鸡蛋的最少的步数为：
$$
F(H,M)
$$
那么可以知道：
$$
F^{i}(H,M) = max(F(k_i-1,M-1),F(H-k_i,M)) \quad i=1,2,3,\dots,N \\
F(H,M) = min(F^i (H,M))
$$
所以就要模拟每一种情况，然后找到每一种策略最多的尝试次数，并找到其中最少的是多少，而在每种策略的模拟中需要利用递归：

```java
class Solution {
    public int superEggDrop(int e, int f) {
        int[][] c = new int[e + 1][f + 1];
        initC(e, f, c);
        return helper(e, f, c); 
    }
    
    public int helper(int e, int f, int[][] c) {
        if(f == 1 || f == 0) return f;
        if(e == 1) return f;
        for(int i = 1;i <= f;i++) {
            int cost = Math.max(helper(e - 1, i - 1, c), helper(e, f - i, c)) + 1;
            c[e][f] = Math.min(c[e][f], cost);
        }
        return c[e][f];
    }
    
    public int[][] initC(int e, int f, int[][] c) {
        for(int i = 2;i <= e;i++) {
            for(int j = 2;j <= f;j++) {
                c[i][j] = Integer.MAX_VALUE;
            }
        }
        return c;
    }
}
```

这种思路是比较容易可以想出来的一种思路：

- 如果只有一个鸡蛋，那么在所有的楼层，最少的尝试次数都是楼层的高度；
- 从每一个楼层分别模拟从这个楼层投掷的情况下分别探索；

这种方法是没有优化过的，也是很直观的解法，但是时间上会很长时间复杂度：
$$
O(F^2 * E)
$$
F 代表的是楼层的高度，E 代表的是鸡蛋的个数；

空间复杂度为：
$$
O(F*E)
$$
这种解决办法是没法 AC 的但是我还是认为这是一个能比较快速想到的方法；

### 2.2 优化1下

​	假设在鸡蛋没有数量限制的情况下你会怎么找？二分查找一定是一个不错的选择。可以这么想，如果在一定的范围选择第一次的扔鸡蛋的楼层位置 h ：

- 碎了，那么剩下的尝试次数为 f(m-1,h) ;
- 没碎，那么剩下的尝试次数为 f(m,H-h); 

这两个较大的数值为 ：
$$
ff = max(f(m-1,h),f(m,H-h))
$$
由之前的两个鸡蛋可知，所有的情况的和是一个确定的数值 S ，那么如果在中间即一半的位置进行扔，那么得到的是一个：
$$
fff = \frac{1}{2}S
$$
其中 ff 一定是一个大于 fff 的数值，所以可以确定二分查找在鸡蛋的个数没有限制的时候是最佳的解决方案；所以可以知道的是在鸡蛋的个数无限多的情况下二分查找的方法是一个尝试次数最小的方法。既然知道尝试的次数最小，那么此时需要的鸡蛋数量也就是尝试的次数。不需要无限个鸡蛋，只要鸡蛋的数量大于等于需要尝试的次数的时候就可以知道最少的尝试的次数。而最小的尝试次数是：
$$
Math.ceil\left(log_2(h+1)\right)
$$
h 代表的是楼层数，如果鸡蛋的个数大于这个最少的尝试次数那么最少的尝试次数也不用算了，就是这个数值。时间复杂度变为：
$$
O(F*log_2{F} * E)
$$

```java
class Solution {
    public int superEggDrop(int e, int f) {
        int[][] c = new int[e + 1][f + 1];
        initC(e, f, c);
        return helper(e, f, c);
        
    }
    public int helper(int e, int f, int[][] c) {
        if(f == 1 || f == 0) return f;
        if(e == 1) return f;
        int t = (int)Math.ceil(Math.log(f+1) / Math.log(2));
        int cost = 0;
        if(e >= t) {
            c[e][f] = t;
            return c[e][f];
        }
        for(int i = 1;i <= f;i++) {
            cost = Math.max(helper(e - 1, i - 1, c), helper(e, f - i, c)) + 1;
            c[e][f] = Math.min(c[e][f], cost);
        }
        return c[e][f];
    }  
    public int[][] initC(int e, int f, int[][] c) {
        for(int i = 2;i <= e;i++) {
            for(int j = 2;j <= f;j++) {
                c[i][j] = Integer.MAX_VALUE;
            }
        }
        return c;
    }
}
```

## 3 别的思路	

​	上面已经进行了应有的优化，但是还是跑不通 leetcode 上的所有用例。这种模拟所有情况的做法，也可以继续优化，但是也都是在模拟的基础上进行的。现在换一个思路进行理解这个问题。如果给你 1 个鸡蛋，i 次尝试，最坏的情况可以尝试多少层？什么可以理解为最坏的情况，就是1个鸡蛋如果给你10层楼，你需要尝试10次。所以给你一个鸡蛋，如果给你 i 次尝试，你最多可以探查到第 i 层楼；

​	所以现在问题变成了用鸡蛋和次数去“摸高”的问题了。每一个鸡蛋都要合理的去利用每一次的尝试使得可以尽可能的有机会探查到更高的楼层。怎么利用呢？直接一个鸡蛋扔到很高很高的 N 层，但是你只有一次机会，这你是无法判断鸡蛋的具体可以碎的楼层的，这不叫摸高或者探查。。所以在每一次的扔鸡蛋，在这个位置碎了/不碎，剩下的鸡蛋和尝试次数都可以帮你准确的找到具体的楼层这才是真正的摸高。

​	所以，在某一层扔了一个鸡蛋：

- （碎了）此时剩下 m-1 个鸡蛋，尝试次数为 k-1 ；
- （没碎）此时剩下 m 个鸡蛋，尝试次数 k-1 ；

假设我们知道在 m-1 个鸡蛋 k-1 次数 或者 在 m 个鸡蛋，k-1次数下的 ”摸高“ 层数，这两个加和 + 1 的到的高度 H 
$$
H =h(m-1, k-1)+h(m, k-1)+1
$$
可以通过 m个鸡蛋，k 次尝试来验证这个鸡蛋仔H层楼高的具体碎的位置，即使是最坏的情况，即这个鸡蛋在 H 这里碎掉。

​	所以下面要做的就是给定鸡蛋的个数，不断的递推下去，直到可以摸高的高度大于 > H 的时候就是最少的尝试次数。

时间复杂度：
$$
O(KlogN)
$$
空间：
$$
O(NK)
$$

```java
class Solution {
public int superEggDrop(int K, int N) {
        int[][] dp = new int[N + 1][K + 1];
        int k = 0;
        while (dp[k][K] < N) {
            ++k;
            for (int m = 1; m <= K; ++m)
                dp[k][m] = dp[k - 1][m - 1] + dp[k - 1][m] + 1;
        }
        return k;
    }
}
```

### 3.1 滚动数组优化

​	常见的 Dp 的优化方式：不需要二维数组，只需要一个一维的数组：

时间：
$$
O(KlogN)
$$
空间： O(K)

```java
class Solution {
        public int superEggDrop(int K, int N) {
        int dp[] = new int[K + 1], m = 0;
        for (k = 0; dp[m] < N; ++k)
            for (int m = K; m > 0; --m)
                dp[m] += dp[m - 1] + 1;
        return k;
    }
}
```

