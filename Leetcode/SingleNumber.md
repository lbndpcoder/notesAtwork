[TOC]

# Single Number

##（1）找到一个数组中只出现一次的数

​	Leetcode 136

​	给一个数组，找到其中只出现一次的数字，其余的数字都只是出现了两次；这个问题是这个系列的思路的基石，用异或操作可以知道：
$$
a \quad XOR \quad b \quad XOR \quad a = b
$$
所以，只要设定一个初始的数字 0 ，和整个数组中的元素分别异或，最终得到的数字就是只出现一次的数字；

##（2）找到一个数组中只出现一次的两个数字

​	Leetcode 260

​	最基本的思路还是利用异或的操作，但是如果像上一个问题一样的操作，最终得到的元素是a异或b的数值（a，b为两个只出现一次的数值）；

​	现在的思路是找到 a 和 b 不同的一位其余的每一位可以为 0 ，找到这个数字之后，就是说明 a 和 b 之间和这个数字做与的操作，一个位 0，一个为 1，这样这个数字和数组中的数字做与操作，如果大于0，那么说明这个数字在和所有数组中做与大于 0 的数字做异或操作之后最终得到是其中的一个目标数字 a ，等于 0 则得到的是另一个数字 b 。

​	现在的目标在于如和找到两个数字不同的那一位并且标为1，

- 首先将所有的数字异或得到的是两个只出现一次的数字的异或；

- 这个数中的为 1 的每一位都是两个数字不同的位数；

- 想要找到从右开始的第一位不同的数字，将数字 - 1，将第一位不同的数字变为 0，并且右侧所有的位全变1；

- 取反之后得到的是第一位不同的数字为 1 ，并且右侧的所有位数为 0 ，左侧的每一位都和原来相反；

- 再和原来的数值做与得到结果；
  $$
  res = a \& -(a - 1)
  $$

## （3）只有一个数字出现一次，其余数字出现三次

​	Leetcode 137

​	之前的重复的数字都只出现了两次，这样只要异或第二次相同的数值的时候就可以将重复的数字 “清空” 。但是现在一个数值会出现三次这样我们的策略如下：（从数字的**每一位**来考虑）

- 我们需要的是三种状态，遇见 x 这个数值的第一次，遇见 x 的第二次，遇见 x 的第三次；
  - 遇见 x 的第三次应该和遇见 x 的第一次之前的状态相同，换句话说就是要在和相同的三个数字进行“碰撞”后得到的数值不变（每一位）
  - （0，0）+ 1 = （0，1）
  - （0，1）+ 1 = （1，0）
  - （1，0）+ 1 = （0，0）
- 无论如何如果碰见的是 0 ，不做改变：
  - （0，0）+ 0 = （0，0）
  - （0，1）+ 0 = （0，1）
  - （1，0）+ 0 = （1，0）

所以这种策略可以成功的将数组中的只出现一次的数字找出来，在每一位上如果碰见的 N*3 的数字这位就会回归于 0 ，如果再碰见一次 1 那么就会为 1 。现在的重点是我们如何实现这个策略；

​	我们用来保存的状态的两个位数位为 1 只有 在他本身为并且另外一个数字为 0 ，并且遇见的为 0 或者 本身为 0 ，另外的两个为 1 ：$(-a \& b \& c) + (-a \& b \& -c) = -a \&(-b\&c + b\&-c) = -a \&(bXORc) $ 就是说通过这种实现方式可以实现每一位的操作。





